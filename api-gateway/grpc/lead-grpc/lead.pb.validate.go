// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api-gateway/grpc/lead-grpc/lead.proto

package proto

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetLeadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLeadRequestMultiError,
// or nil if none found.
func (m *GetLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetLeadRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetLeadRequestMultiError(errors)
	}

	return nil
}

// GetLeadRequestMultiError is an error wrapping multiple validation errors
// returned by GetLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeadRequestMultiError) AllErrors() []error { return m }

// GetLeadRequestValidationError is the validation error returned by
// GetLeadRequest.Validate if the designated constraints aren't met.
type GetLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeadRequestValidationError) ErrorName() string { return "GetLeadRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeadRequestValidationError{}

// Validate checks the field values on GetLeadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLeadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLeadResponseMultiError, or nil if none found.
func (m *GetLeadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLeadResponseValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLeadResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLeadResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLeadResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLeadResponseValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLeadResponseValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLeadResponseValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetLeadResponseMultiError(errors)
	}

	return nil
}

// GetLeadResponseMultiError is an error wrapping multiple validation errors
// returned by GetLeadResponse.ValidateAll() if the designated constraints
// aren't met.
type GetLeadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeadResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeadResponseMultiError) AllErrors() []error { return m }

// GetLeadResponseValidationError is the validation error returned by
// GetLeadResponse.Validate if the designated constraints aren't met.
type GetLeadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeadResponseValidationError) ErrorName() string { return "GetLeadResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetLeadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeadResponseValidationError{}

// Validate checks the field values on GetLeadsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLeadsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeadsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLeadsRequestMultiError, or nil if none found.
func (m *GetLeadsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeadsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEmpty()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLeadsRequestValidationError{
					field:  "Empty",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLeadsRequestValidationError{
					field:  "Empty",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmpty()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLeadsRequestValidationError{
				field:  "Empty",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetLeadsRequestMultiError(errors)
	}

	return nil
}

// GetLeadsRequestMultiError is an error wrapping multiple validation errors
// returned by GetLeadsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLeadsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeadsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeadsRequestMultiError) AllErrors() []error { return m }

// GetLeadsRequestValidationError is the validation error returned by
// GetLeadsRequest.Validate if the designated constraints aren't met.
type GetLeadsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeadsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeadsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeadsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeadsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeadsRequestValidationError) ErrorName() string { return "GetLeadsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLeadsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeadsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeadsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeadsRequestValidationError{}

// Validate checks the field values on GetLeadsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLeadsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeadsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLeadsResponseMultiError, or nil if none found.
func (m *GetLeadsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeadsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLeadsResponseValidationError{
						field:  fmt.Sprintf("Leads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLeadsResponseValidationError{
						field:  fmt.Sprintf("Leads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLeadsResponseValidationError{
					field:  fmt.Sprintf("Leads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetLeadsResponseMultiError(errors)
	}

	return nil
}

// GetLeadsResponseMultiError is an error wrapping multiple validation errors
// returned by GetLeadsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetLeadsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeadsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeadsResponseMultiError) AllErrors() []error { return m }

// GetLeadsResponseValidationError is the validation error returned by
// GetLeadsResponse.Validate if the designated constraints aren't met.
type GetLeadsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeadsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeadsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeadsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeadsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeadsResponseValidationError) ErrorName() string { return "GetLeadsResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetLeadsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeadsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeadsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeadsResponseValidationError{}

// Validate checks the field values on NewLeadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NewLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NewLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NewLeadRequestMultiError,
// or nil if none found.
func (m *NewLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *NewLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NewLeadRequestValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NewLeadRequestValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NewLeadRequestValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NewLeadRequestMultiError(errors)
	}

	return nil
}

// NewLeadRequestMultiError is an error wrapping multiple validation errors
// returned by NewLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type NewLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NewLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NewLeadRequestMultiError) AllErrors() []error { return m }

// NewLeadRequestValidationError is the validation error returned by
// NewLeadRequest.Validate if the designated constraints aren't met.
type NewLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NewLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NewLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NewLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NewLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NewLeadRequestValidationError) ErrorName() string { return "NewLeadRequestValidationError" }

// Error satisfies the builtin error interface
func (e NewLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNewLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NewLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NewLeadRequestValidationError{}

// Validate checks the field values on NewLeadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NewLeadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NewLeadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NewLeadResponseMultiError, or nil if none found.
func (m *NewLeadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NewLeadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NewLeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NewLeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NewLeadResponseValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NewLeadResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NewLeadResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NewLeadResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NewLeadResponseMultiError(errors)
	}

	return nil
}

// NewLeadResponseMultiError is an error wrapping multiple validation errors
// returned by NewLeadResponse.ValidateAll() if the designated constraints
// aren't met.
type NewLeadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NewLeadResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NewLeadResponseMultiError) AllErrors() []error { return m }

// NewLeadResponseValidationError is the validation error returned by
// NewLeadResponse.Validate if the designated constraints aren't met.
type NewLeadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NewLeadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NewLeadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NewLeadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NewLeadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NewLeadResponseValidationError) ErrorName() string { return "NewLeadResponseValidationError" }

// Error satisfies the builtin error interface
func (e NewLeadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNewLeadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NewLeadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NewLeadResponseValidationError{}

// Validate checks the field values on PutLeadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PutLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PutLeadRequestMultiError,
// or nil if none found.
func (m *PutLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := PutLeadRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutLeadRequestValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutLeadRequestValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutLeadRequestValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutLeadRequestMultiError(errors)
	}

	return nil
}

// PutLeadRequestMultiError is an error wrapping multiple validation errors
// returned by PutLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type PutLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutLeadRequestMultiError) AllErrors() []error { return m }

// PutLeadRequestValidationError is the validation error returned by
// PutLeadRequest.Validate if the designated constraints aren't met.
type PutLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutLeadRequestValidationError) ErrorName() string { return "PutLeadRequestValidationError" }

// Error satisfies the builtin error interface
func (e PutLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutLeadRequestValidationError{}

// Validate checks the field values on PutLeadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutLeadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutLeadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutLeadResponseMultiError, or nil if none found.
func (m *PutLeadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutLeadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutLeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutLeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutLeadResponseValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutLeadResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutLeadResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutLeadResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutLeadResponseValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutLeadResponseValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutLeadResponseValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutLeadResponseMultiError(errors)
	}

	return nil
}

// PutLeadResponseMultiError is an error wrapping multiple validation errors
// returned by PutLeadResponse.ValidateAll() if the designated constraints
// aren't met.
type PutLeadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutLeadResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutLeadResponseMultiError) AllErrors() []error { return m }

// PutLeadResponseValidationError is the validation error returned by
// PutLeadResponse.Validate if the designated constraints aren't met.
type PutLeadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutLeadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutLeadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutLeadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutLeadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutLeadResponseValidationError) ErrorName() string { return "PutLeadResponseValidationError" }

// Error satisfies the builtin error interface
func (e PutLeadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutLeadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutLeadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutLeadResponseValidationError{}

// Validate checks the field values on DeleteLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLeadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLeadRequestMultiError, or nil if none found.
func (m *DeleteLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteLeadRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteLeadRequestMultiError(errors)
	}

	return nil
}

// DeleteLeadRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLeadRequestMultiError) AllErrors() []error { return m }

// DeleteLeadRequestValidationError is the validation error returned by
// DeleteLeadRequest.Validate if the designated constraints aren't met.
type DeleteLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLeadRequestValidationError) ErrorName() string {
	return "DeleteLeadRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLeadRequestValidationError{}

// Validate checks the field values on DeleteLeadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLeadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLeadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLeadResponseMultiError, or nil if none found.
func (m *DeleteLeadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLeadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return DeleteLeadResponseMultiError(errors)
	}

	return nil
}

// DeleteLeadResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteLeadResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteLeadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLeadResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLeadResponseMultiError) AllErrors() []error { return m }

// DeleteLeadResponseValidationError is the validation error returned by
// DeleteLeadResponse.Validate if the designated constraints aren't met.
type DeleteLeadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLeadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLeadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLeadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLeadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLeadResponseValidationError) ErrorName() string {
	return "DeleteLeadResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLeadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLeadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLeadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLeadResponseValidationError{}

// Validate checks the field values on PatchLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PatchLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PatchLeadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PatchLeadRequestMultiError, or nil if none found.
func (m *PatchLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PatchLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PatchLeadRequestValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PatchLeadRequestValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PatchLeadRequestValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetId() <= 0 {
		err := PatchLeadRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PatchLeadRequestMultiError(errors)
	}

	return nil
}

// PatchLeadRequestMultiError is an error wrapping multiple validation errors
// returned by PatchLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type PatchLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PatchLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PatchLeadRequestMultiError) AllErrors() []error { return m }

// PatchLeadRequestValidationError is the validation error returned by
// PatchLeadRequest.Validate if the designated constraints aren't met.
type PatchLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PatchLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PatchLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PatchLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PatchLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PatchLeadRequestValidationError) ErrorName() string { return "PatchLeadRequestValidationError" }

// Error satisfies the builtin error interface
func (e PatchLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPatchLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PatchLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PatchLeadRequestValidationError{}

// Validate checks the field values on PatchLeadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PatchLeadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PatchLeadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PatchLeadResponseMultiError, or nil if none found.
func (m *PatchLeadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PatchLeadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PatchLeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PatchLeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PatchLeadResponseValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PatchLeadResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PatchLeadResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PatchLeadResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PatchLeadResponseValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PatchLeadResponseValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PatchLeadResponseValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PatchLeadResponseMultiError(errors)
	}

	return nil
}

// PatchLeadResponseMultiError is an error wrapping multiple validation errors
// returned by PatchLeadResponse.ValidateAll() if the designated constraints
// aren't met.
type PatchLeadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PatchLeadResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PatchLeadResponseMultiError) AllErrors() []error { return m }

// PatchLeadResponseValidationError is the validation error returned by
// PatchLeadResponse.Validate if the designated constraints aren't met.
type PatchLeadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PatchLeadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PatchLeadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PatchLeadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PatchLeadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PatchLeadResponseValidationError) ErrorName() string {
	return "PatchLeadResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PatchLeadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPatchLeadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PatchLeadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PatchLeadResponseValidationError{}
